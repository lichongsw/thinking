# 异曲

如果需要精确查询，直接hash就行。面对搜索引擎的搜索推荐或者拼写的补全这类场景的时候，惯性的方案是使用的trie树这种适合处理前缀的结构。B+树这种在叶子结点层使用链表连接元素的结构对范围查询也是非常友好。

## 索引的差异

两者都是多叉树结构，只是B+树的限制多一点（还是磁盘引起的页面限制）。trie树的索引可以看成某种进制，例如全部是小写字母的时候就是26进制

1. 树的顶层存的是最高位，叶子节点存的是最低位。元素是被分解存到各节点的，是尽量利用已经拥有的节点

2. 节点的子节点的是从左到右按照从小到大的方式平铺，

3. 单个节点最多就是26个子节点

4. 树的高度等于搜索库中最长元素

B+树的索引本质是动态规划，采用分段排序，往树的下层搜索来逼近目标。

1. 树的非叶子节点层存的是逼近目标用的标识，叶子节点才会存储元素自身

2. 同一层的节点的标识也是从左到右按照从小到大的方式平铺

3. 单个非叶子节的子节点个数与标识的大小成反比

4. 树的高度较低，是以3中子节点个数为底数库中元素总量的对数

## 再思考一下

如果是做热搜榜，不仅要有完整性提示还要考虑热度的时候改如何处理呢？trie树可以配合hash表来记录热度的权重来实现，B+树只需要添加字段记录即可。小范围的有限集合适合用trie树，trie树反应的是全貌并在节点中分解元素，是整体常驻内存的。大范围的数据还是要持久化到硬盘，内存中只存储各种标识。

其实数据的存储发展也是极快，不用死盯着经典模型。传统的硬盘数据库模型目前还是主流（ssd延伸了这一模型的生命周期）。在特定场景下，必定会出现内存的收益大于使用成本，事情就又会回归到原始的线性地址那一套了。例如用redis给mysql做热点数据缓存就是如此。往后看内存数据库模型必定会发展出更高效的使用方式，让人拭目以待了。
