# 为啥要搞出线程和用户态，内核态权限
早期电子设备都是巨贵无比的单片机，没有操作系统的概念。整个设备就运行一个汇编或者c程序，调度全部靠中断。各种通讯例如串口，网口或者键盘等等，
一堆中断向量表记录了各种对应处理程序的函数指针。这样搞只有厂商才能玩，用户随便写错点啥整个设备就挂了。所以必须把厂商和用户独立开来
才有前途，强调一下用户特指开发应用程序的程序员。厂商推出操作系统接管了硬件仅运行在内核态。用户专心编写特定领域的应用程序存粹逻辑部分运行在用户态，
与操作系统有交互时（软中断，硬中断，异常）进入内核态。

# 线程切换时机
为了使用紧缺资源CPU，线程有各种被调度机制，有公平轮转也有优先级抢占。linux用来调度的函数是schedule()，在内核态运行。时机有两种：
1. 系统调用或者中断返回时，根据标志决定是否调用schedule()函数。此时即将进入用户态，趁着还在内核态进行一次调度。对应的是系统调用的切换开销。
2. 第当前任务阻塞或者睡眠，调用schedule()函数由用户态进入内核态进行任务调度。

# 线程切换具体开销
一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。
1. 用户级上下文: 正文、数据、用户堆栈以及共享存储区；
2. 寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
3. 系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

上下文切换分为进程调度时和系统调用时两种切换，消耗资源不同。当发生进程调度时，进行进程切换就是上下文切换(context switch)。开销是1+2+3
而系统调用进行的模式切换(mode switch)与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切换。开销是3

# 对比线程和协程切换开销
对于c与go来说，不管是线程还是协程涉及系统调用是都要进入内核态执行系统调用的，没有区别，这里对比的是context switch。
协程有更小的栈，调度方式是协作，更像小兵团合作，用起来灵活轻便。切换成本类似mode switch，只需要把寄存器信息保存到栈里，等下次调度再恢复运行。
线程栈更大（相比协程有3个数量级），调度方式是被中央调度，像集团军统一指挥，用起来比较粗狂。线程数量多而且干活少时，切换的开销都可能比线程干活的开销都大。
