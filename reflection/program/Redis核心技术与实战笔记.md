笔记类别的不记录原文内容，给出一个链接杰克，主要记录阅读重点内容以及以及自己的体会。

原文链接（极客时间课程：Redis核心技术与实战）：https://time.geekbang.org/column/article/268262



# 01 | 基本架构：一个键值数据库包含什么？



要对它的总体架构和关键模块有一个全局的认知，然后再深入到具体的技术点。这个学习思路可以让自己的学习、工作效率更高。

理解了数据模型，你就会明白为什么在有些场景下原先使用关系型数据库保存的数据，也可以用键值数据库保存。例如，用户信息（用户 ID、姓名、年龄、性别等）通常用关系型数据库保存，在这个场景下，一个用户 ID 对应一个用户信息集合，这就是键值数据库的一种数据模型，它同样能完成这一存储需求。但是，如果你只知道数据模型，而不了解操作接口的话，可能就无法理解为什么在有些场景中使用键值数据库又不合适了。例如，同样是在上面的场景中，如果你要对多个用户的年龄计算均值，键值数据库就无法完成了。因为它只提供简单的操作接口，无法支持复杂的聚合计算。



**可以存哪些数据？**

对于 Redis 来说，它到底能做什么，不能做什么呢？只有先搞懂它的数据模型和操作接口，我们才能真正把“这块好钢用在刀刃上”。不同键值数据库支持的 key 类型一般差异不大，而 value 类型则有较大差别。我们在对键值数据库进行选型时，一个重要的考虑因素是它支持的 value 类型。例如，Memcached 支持的 value 类型仅为 String 类型，而 Redis 支持的 value 类型包括了 String、哈希表、列表、集合等。Redis 能够在实际业务场景中得到广泛的应用，就是得益于支持多样化类型的 value。



**可以对数据做什么操作？**

一样的CURD基本操作，简单点可以理解成：

PUT：新写入或更新一个 key-value 对；

GET：根据一个 key 读取相应的 value 值；

DELETE：根据一个 key 删除整个 key-value 对。

根据一段 key 的范围返回相应的 value的 SCAN操作也算是一个键值数据库的基本操作。（其实这个就决定了很多好用的功能）



**数据做存储在哪个地方？**

保存在内存的好处是读写很快，毕竟内存的访问速度一般都在百 ns 级别。但是，潜在的风险是一旦掉电，所有的数据都会丢失。保存在外存，虽然可以避免数据丢失，但是受限于磁盘的慢速读写（通常在几 ms 级别），键值数据库的整体性能会被拉低。

比如，缓存场景下的数据需要能快速访问但允许丢失，那么，用于此场景的键值数据库通常采用内存保存键值数据。



**大致框架会长什么样子？**

不管框架结构怎么定，肯定有单机（传统）和网络（主流）两种常用方式。例如，RocksDB 以动态链接库的形式使用，而 Memcached 和 Redis 则是通过网络框架访问。与通用服务的涉及类似，访问的接入，数据处理（写入和读取），数据存储，服务治理这几个正交的模块是少不了的。

访问接入：pipe技术，单线程，

数据处理写入/读取：数据结构（树，跳表，hash表）之类独写复杂度控制（时间，空间）

数据存储：内存，内外存结合（内存各种分配回收策略，外存的各种缓冲技术，顺序写，可靠程度控制）

服务治理：主从，集群，高可用，重启恢复（这些与上面的选择息息相关）



可以看到redis实现框架的过程：

![img](https://static001.geekbang.org/resource/image/30/44/30e0e0eb0b475e6082dd14e63c13ed44.jpg)



**常见使用场景带来的扩展功能**

所谓功能特性，就是一些做法符合某个业务场景。可以比较自然的做出业务需要的效果。然而就有通用的问题（每个实现的解决方案和倾向不同，只是问题类似）

1. 作为缓存使用，就有数据淘汰策略以及数据一致性问题（缓存cache aside，cache through）
2. 作为分布式锁使用，也有锁定和释放操作
3. 作为秒杀系统使用预分配资源（缓存和锁的结合）
4. 网络访问就有reactor模型，然后命令就有合批操作（pipe）
5. 高可用自然有主从，独写分离



# 02 | 数据结构：快速的Redis有哪些慢操作？

Redis给人的映像是块，但也不用这个标题来吸引眼球。刨除外部的影响，数据结构的设计是纯内存操作的第一要素。正确的数据结构能够平衡时间和空间的复杂度，有稳定的高效率操作。

从字面意思讲键值对中值的数据类型如下，

1. String
2.  List
3.  Hash 
4. Set 
5. Sorted Set
6. Bitmap
7. GeoHash 
8. HyperLogLog （使用的少）
9. Streams （新标准）



而键与值（对于集合类型，其实是指针）之间使用hash表来连接，看重的就是稳定的O(1)寻址能力。但也rehash时大量数据挪动的烦恼（基本用渐进式rehash来分摊压力，golang语言也是这么干的。这个理念就是内存便宜了，在非指数级增长的情况下都可以选择用空间来换时间，以及减低复杂度）

![img](https://static001.geekbang.org/resource/image/82/01/8219f7yy651e566d47cc9f661b399f01.jpg)

![img](https://static001.geekbang.org/resource/image/1c/5f/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg)



底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。这些就不写了，其他阅读记录中有。

![img](https://static001.geekbang.org/resource/image/fb/f0/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg)



单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。



范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据，比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。除了真的需要所有数据的场景，基本上SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN）渐进式遍历才是正确的选择。



统计操作，是指集合类型对集合中所有元素个数的记录，例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)。



对于 List 类型，既然它的 POP/PUSH 效率很高，那么就将它主要用于 FIFO 队列场景，而不是作为一个可以随机读写的集合。（这个就不说了，链表的特性）。换和场景的时候出发点又不一样，Redis的List底层使用压缩列表本质上是将所有元素紧挨着存储，所以分配的是一块连续的内存空间。虽然数据结构本身没有时间复杂度的优势，但是这样节省空间而且也能避免一些内存碎片（节省估计谈不上，但少碎片是真，这种就像小对象池的概念）



# 03 | 高性能IO模型：为什么单线程Redis能那么快？



Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。网络和内存IO都算高速（相比外存，锁控制）来说，这些都是非常快的操作。这些还是没有走出非阻塞IO+多路复用的老套路（epoll）。

![img](https://static001.geekbang.org/resource/image/00/ea/00ff790d4f6225aaeeebba34a71d8bea.jpg)

这种场景确实适合，没有耗时操作的时候单线程的速度是最有效率的（只要需要处理的数据吞吐量没有达到单线程处理能力的上限，那就是最好的做法）。2GHz单核心20W数量级的QPS，可以轻松满足大部分的场景的需求了。（变态头部公司除外，用户体量摆在那里）。从这里可以看出一些缺陷，QPS很难在数量级上有提升，而且在处理比较大的value的时候，性能会下降（双1配置下大量都写数据，磁盘IO会拖后腿的。在返回大value数据的时候，网络开销也会明显变大。这里零拷贝没有kafaka做的好）。



最近6.0也引入了多线程IO，顺便借这位网友的总结来理解一下单线程到多线程的变化：

https://zhuanlan.zhihu.com/p/144805500

不用看也知道命令的执行还是单线程，这个不想碰锁的话是改不了的（反正内存操作+简单运算，以内存和CPU的频率，这里不会这么早出现瓶颈）。**多线程只能是IO上发力，而且仅仅是网络IO。执行还是单线程，数据运算上没有任何问题。这个意义感觉不大，没有质变的提升，仅仅是网络负载的优化。对于大公司还是有意义的，人家客户端数据量足够大。**



真正的瓶颈以及有意义的方向应该是这些：

1. 操作big key的提升：写入一个big key在分配内存时需要消耗更多的时间，同样，删除big key释放内存同样会产生耗时；（内存分配回收算法的提升以及异步释放优化）
2. 优化淘汰策略，提高命中率（在高命中率的前提下，不要因为内存绝对量太少而不停淘汰热点）
3. 双1的刷盘，SSD已经很优秀了，以后会越来越好

预防性的使用方式：

1. 避免单次操作大量数据（复杂度高的命令要拆分，多用scan）
2. 避免key的几种过期（老生常谈）
3. 各种同步不能影响线上性能（注意时机）



# 04 | AOF日志：宕机了，Redis如何避免数据丢失？

作为缓存来说一旦服务器宕机，内存中的数据将全部丢失。很容易想到的一个解决方案是，从后端数据库恢复这些数据，但这种方式存在两个问题：一是，需要频繁访问数据库，会给数据库带来巨大的压力；二是，这些数据是从慢速数据库中读取出来的，性能肯定比不上从 Redis 中读取，导致使用这些数据的应用程序响应变慢。所以对 Redis 来说实现数据的持久化，避免从后端数据库中进行恢复是至关重要的。即使不从数据库读取，从文件中恢复也是比较慢的（相比于访问来说）。