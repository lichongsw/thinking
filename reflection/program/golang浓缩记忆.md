# 按自己的理解记忆

作为工程实用型语言，还是得通过重新组织简写的方式来加深理解，以便以后快速浏览恢复记忆。只记录各种工程设计，不记录语法知识点。
开始记录之前先写最直观的感受，就是golang尽量把事情在用户态做的，没办法的时候才会求助于操作系统。最主要的部分就是下面的内存管理和调度。

## 内存管理与GC

1. 使用TCMalloc，申请时找操作系统要一大片来做内存池的二次管理，回收时尽量重用而不是还给系统。
2. 池子有两种主要使用方式，一是block pool即66种固定大小的单元，另一种是byte pool用来处理大于32KB的使用场景，尽量避免了碎片化。
3. 二次管理对各个内存页面单元8KB（arena）添加了两种标记（bitmap，存放是否使用，是否被GC标记）和一个双链表索引（mspan结构体指针，保存内存页面的偏移量以及页数，pool的类型）。
4. 协程G只能在绑定的用户级逻辑处理器P的环境（mcache，拥有一批各种大小的池子。结构类似hash表，只有67个slot，同一个slot后面用链表挂上span）中运行。同一时间P只能运行一个P，所以G向P申请内存是无锁的。mcacha初始化的时候是空的，随着运行G就会得到资源，使用后并缓存下来就可以提供给后面的G使用。
5. mcache的资源来源于mcentral，central维护着各种大小pool的忙和空闲链表。切分资源给mcache的时候需要加锁避免并发问题，本质有两点，一是预分配机制来减少锁的次数，二是正交归类高概率的固定大小池子来减少锁之间的冲突。
6. mheap是go持有的整个堆空间。就是前面说的那一大片。管理着mcentral，span，bitmap，arena。
7. 根据对象的大小分配策略略有变化，极小的会被合并，中等的就用适合大小的固定池，大于32KB的就直接由mheap来管理。
8. GC主要是并发的三色标记清除法，有STW的影响。标记阶段使用混合写屏障（扫描结束后STW重新扫描的插入写以及扫描开始前STW记录快照的删除写）来减少STW时间，清除阶段与用户代码并行。写屏障(Write Barrier)，相当于程序在写指针操作的地方插入一段代码，当用户程序修改内存引用时，如果有黑色对象引用了白色对象，则把相应白色对象移入灰色集合，如果是新分配的对象则直接放入黑色集合。
9. 逃逸分析，就是编译器确认能够放在栈里面的东西就不放堆里面的优化。这中模糊对于栈的使用场景的方式算是工程化的典型，能够让使用者减轻了使用负担。例如c语言里面弄个栈上的变量取地址丢出去一会栈回收就啥都没有了，而go的编译器会发现这点。有点类似sql的声明式的做法，你只需要告诉编译器要个变量，至于放哪取决于后面的代码怎么使用这个变量。

## 协程routine

先说最明显的感觉，就是调度把各种长等待型事件（调度，IO）尽量变成了密集运算型事件。就是不管发生什么耗时操作，要么把他交给异步任务处理，要么新开资源处理剩下的，就是不能原地等待。因此需要引入间接层来解耦协程与线程的直接关联。对于CPU密集型的场合，估计golang对比原有的方案也没有多大的提升。对IO密集型那可能就有数量级上的优势了。推测IO密集型的应用适合go，cpu密集型的反而不是go的特长，毕竟这么大的runtime的开销也不小。

1. 协程G就是一个入口函数和后面的调用逻辑，有自己专用的栈。跟其他栈一样，主要是临时变量和子函数调用。亮点是起点小可大量使用，而自适应大小做扩容和缩容，不会轻易爆栈和浪费空间。扩容原理就是每次执行函数前检查一下栈空间是否够用，不够的话就扩容一倍拷贝到新栈。可能多一些检查指令影响不大，而扩容的频率并不高，这个对性能就没有那么明显的影响了。缩容是GC做的，使用率不到25%就缩容一半。举例说100w级别的连接，就算简单暴力使用全双工的方式开出200w的读写分离的连接G（配合channel和逻辑G工作组，毕竟扩容到100w的基数上那就负担重了），都只占用8G内存。对一般业务来说足够使用了。
2. 逻辑处理器P就是为了解耦CPU物理核心内核线程和G之间的直接关联，作为分时操作的用户态基础单元来让多个G轮换使用。P支持G的负载均衡（主动去其他P抢），并管理和缓存堆资源为G提供无锁内存支持。
3. 关联内核线程的M就没有具体线程状态了（G的栈是自己私有的，其实也有一小部分状态就是与调度相关的G0），存粹是提供运算量的单元。所以M可以对应多个P，不过这样意义不大。只要P等于M的时候还能够全负荷运行，M的负荷也会满，golang倾向于用更少的高负荷线程把事情做完。
4. 同步IO时P会解除与M的绑定，寻找新的可用M继续执行剩余的其他G。阻塞的G就暂时挂在M上，完成后G会被还给P排队等待调度。这个过程中M发生了变化。
5. 异步IO时将G挂到NetPoller等通知，P不受影响继续执行剩余的其他G。如果异步操作完成了G会被还给P排队等待调度。
6. 协同式调度对标抢占式调度，还是偏向于实用化。协同嘛，肯定有人不服从指挥的，所以有个sysmon监控G的运行时间。它会让运行时间久的G标记为栈空间缺失，而在下一个函数调用的时候被切出去。但是没办法中断没有函数调用的G的，一不小心搞出个没有函数调用的死循环就麻烦了，完全没有机会调度了。从以前的经历来看，实时抢占是用来解决特定领域的强实时性需求，例如RTOS这种在嵌入式的工业设备上那叫一个普及，追求的是精确的控制。反观社会生活中的各种服务行业并不需要这样极端的优先级保证，只要能够把大部分做的足够好就可以了。
7. 同步的控制方式主要是用chanel。其他小众的做法有waitgroup，类似线程级别的join，需要等待其他人干完活。还有一个context，后面需要配合的其他人是可以被取消的，这个有点降级的概念用来直接掐掉不保证结果的后续动作。

## 通道chanel

1. 这个看起来先进的概念就是个语言级别提供的带锁的队列（高级语法糖），配合G使用才有点与众不同。简单说就是G才是争用队列锁的单位，要阻塞只是挂住G了，与塞住一个线程来比那开销小太多了。chanel会为读，写分别维护独立的双向链表，保存所有与之有关的G的连接。
2. 再说一下select和case，这个有点类似操作系统的epoll监控多个文件描述符那样的方式来监控多个chanel，但是只返回一个有变化的chanel或者default。
