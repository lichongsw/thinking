# **应用架构之道：分离业务逻辑和技术细节**

## 背景

### 1. 什么是架构？



关于架构这个概念很难给出一个明确的定义，也没有一个标准的定义。



硬是要给一个概述，我认为**架构就是对系统中的实体以及实体之间的关系所进行的抽象描述**。



架构始于建筑，是因为人类发展（原始人自给自足住在树上，也就不需要架构），**分工协作的需要，将目标系统按某个原则进行切分，切分的原则，是要便于不同的角色进行并行工作**。

在有资源的项目中并行工作是常态，而且大的项目团队规模都不小，没有指导思想不容易形成合力和高质量产出（汽车行业的精益生产算是制造业的指导典范）。只有形成一个分解的共识之后才能划分出角色，进一步的明确职责范围，保持内聚和简单才能化解掉业务的复杂性。<!--在偏业务的公司（大部分能够活在市场上的公司）架构大多时候是在玩套娃，然后局部有针对性的根据业务领域做一点小调整。真正能够指出方向并落地成为被其他大公司套娃对象的架构（例如2010年前google的三大核心技术：GFS，MapReduce，BigTable）都是对行业有卓越的贡献和深远的影响的。普通级别的项目基本上就先分层，然后在具体层中切分模块（静态视图），然后以各种同步/异步的消息，事件调用框架辅助一下数据流动（动态视图）因该就差不多了。比较麻烦一点的地方是切分，这个需要理解领域的知识才能找出比较高效的切分方式。-->



### **2. 为什么需要架构？**



有系统的地方就需要架构，大到航空飞机，小到一个电商系统里面的一个功能组件都需要设计和架构。

我很喜欢《系统架构：复杂系统的产品设计与开发》里面的一句话：**结构良好的创造活动要优于毫无结构的创造活动**。

与之相对应的，在很多敏捷思想提倡 no design，只要 work 就好。期待好的架构可以在迭代中自然涌现。这个想法有点太理想化了，在现实中，只要能 work 的代码，工程师是很少有动力去重构和优化的。<!--同感，所以设计阶段一定要发表自己的意见，底线是自己不反对（这个分寸是有必要的，不要强求别人接受自己的意见，因为技术上很多选择都是跟随环境变化的。即使在同一个上下文中，也有可能出现差不多分数的技术方案。不反对的意思是即使这个事情分配给自己，也愿意按照团队选择的方案做实现）。不然定型之后，再差的代码也得继续维护。-->

<!--真实工作中直接重构别人的一大块功能的风险之大是超出个人的承受能力的，除非团队一起承担才能干（这种技术债务如果上面没有人拍板，如果有遗漏业务只会看到技术搞出事故，即使做的完美技术团队之外也不会有多少的反馈。特别是那些生命周期短的项目，更加没谱）。-->



### **3. 架构师的职责**

作为架构师，我们最重要的价值应该是“化繁为简”。但凡让事情变得更复杂，让系统变得更晦涩难懂的架构都是值得商榷的。

**架构师的工作就是要努力训练自己的思维，用它去理解复杂的系统，通过合理的分解和抽象，使哪些系统不再那么难懂**。我们应该努力构建易懂的架构，使得在系统上工作的其他人员（例如设计者、实现者、操作员等）可以较为容易地理解这个系统。<!--大粒度的化繁为简在长期的训练中是比较容易出经验的，而细粒度的分解和抽象需要不少编码量的支持，而且在各个领域上细粒度上的操作差异是挺大的，不容易形成共识。-->



## **软件架构**



软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通信。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。



软件架构为**软件系统提供了一个结构、行为和属性的高级抽象**，由构件的描述、构件的相互作用、指导构件集成的模式以及这些模式的约束组成。软件架构不仅显示了软件需求和软件结构之间的对应关系，而且指定了整个软件系统的组织和拓扑结构，提供了一些设计决策的基本原理。



软件架构的核心价值应该只围绕一个核心命题：控制复杂性。他并不意味着某个特定的分层结构，某个特定的方法论（贫血、DDD 等）。



### **1. 软件架构分类**



在介绍应用架构之前，我们先来看一下软件架构的分类。



随着互联网的发展，现在的系统要支撑数亿人同时在线购物、通信、娱乐的需要，相应的软件体系结构也变得越来越复杂。软件架构的含义也变得更加宽泛，我们不能简单地用一个软件架构来指代所有的软件架构工作。按照我个人理解，我将软件架构划分为：



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCajH1rCK5c0QJWDQr1n3c2Ftv3rs3sbGtmpjazu6ibnZVIMvoHzOztdw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



**业务架构**：由业务架构师负责，也可以称为业务领域专家、行业专家。业务架构属于顶层设计，其对业务的定义和划分会影响组织结构和技术架构。例如，阿里巴巴在没有中台部门之前，每个业务部门的技术架构都是烟囱式的，淘宝、天猫、飞猪、1688 等各有一套体系结构。而后，成立了共享平台事业部，打通了账号、商品、订单等体系，让商业基础实施的复用成为可能。<!--目前的游戏业务也做了类似的操作，理论上登录，用户，商品，活动，分享之类的非游戏自生逻辑的模块都是可以在多个项目中复用的。-->



**应用架构**：由应用架构师负责，他需要根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维护性的同时，确保应用满足非功能属性要求（性能、安全、稳定性等）。<!--这个应用基础设施基本上是大量复用的，项目在经历多个线上运营项目后肯定会积累出一套的。-->



**分布式系统架构**：分布式系统基本是稍具规模业务的必选项。它需要解决服务器负载，分布式服务的注册和发现，消息系统，缓存系统，分布式数据库等问题，同时架构师要在 CAP（Consistency，Availability，Partition tolerance）之间进行权衡。<!--这个是服务端的范围，游戏项目游戏服上肯定是分布式的，入口网关应该也是（稍微有点规模都是需要多个入口的）。缓存基本上也是一定会用的，同时在线人数过万了那肯定是会在用户模块，配置，各种容器型列表数据（帮会，圈子，排行榜等等各种高频数据上设置缓存的）。消息系统看情况，量不大就不用（直接用缓存代替）。分布式数据库一般不用，也就是个主从备份或者独写分离之类的，真正需要分片的数据库那是很大的游戏项目才有的。-->



**数据架构**：对于规模大一些的公司，数据治理是一个很重要的课题。如何对数据收集、数据处理提供统一的服务和标准，是数据架构需要关注的问题。其目的就是统一数据定义规范，标准化数据表达，形成有效易维护的数据资产，搭建统一的大数据处理平台，形成数据使用闭环。<!--这一块是新生代的代表，与传统维度不一样。既不是业务导向（产品），也不是应用导向（传统工程师），也不是分布式导向（大型系统工程师），这是一种比较新的方向。可能许多公司不一定有能力处理好这些数据或者说意识到这里的价值。（杀熟，倒卖信息之类的稀烂操作就不说了。数据的价值远远超出这种低级使用方式）-->



**物理架构**：物理架构关注软件元件是如何放到硬件上的，包括机房搭建、网络拓扑结构，网络分流器、代理服务器、Web 服务器、应用服务器、报表服务器、整合服务器、存储服务器和主机等。



**运维架构**：负责运维系统的规划、选型、部署上线，建立规范化的运维体系。





## **典型应用架构**



### **1. 分层架构**



分层是一种常见的根据系统中的角色（职责拆分）和组织代码单元的常规实践。常见的分层结构如下图所示：



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCz74lOictXLUHDue7WD2atmu7zeAqdciaTiaNCN7lV4zJ61EIIG4iawOIDg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





### **2. CQRS**

CQS(Command Query Separation，命令查询分离)，最早来自于 Betrand Meyer（Eiffel 语言之父，OCP 提出者）提出的概念。其基本思想在于，任何一个对象的方法可以分为两大类：

- **命令**(Command): 不返回任何结果(void)，但会改变对象的状态。

- **查询**(Query): 返回结果，但是不会改变对象的状态，对系统没有副作用。

<!--老实说，这个看起来简单，但是不一定被正确的理解。一个命令接口通常会被实现为返回结果给调用者（如果是同步编程的话还好），如果是异步或者这个命令要去远端执行（面临各种不可预知的问题）就不应该再返回任何结果了。对于接口的使用者，正确的做法是先调用命令接口做一件业务上状态有改变的事情，然后命令被远端执行后再丢一个事件通知使用者去调用查询接口获取结果，但有一些使用者也可能会选择设置超时后主动调用查询接口以免一直等不到通知。招行手机银行转账的的表现就是典型的命令+查询使用方式。在设置好转账参数后点击确定按钮之后会弹出一个几秒钟的倒计时UI，提示不要操作，计时结束后显示转账成功的页面。-->

![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCPKRkEPqSibGTpHpCo4MWgbU24AYp6SBJTO3jU5o42hiakuShCkKqQXaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





### **3. 六边形架构**



六边形架构是 Alistair Cockburn 在 2005 年提出，解决了传统的分层架构所带来的问题，实际上它也是一种分层架构，只不过不是上下，而是变成了内部和外部（如下图所示）。



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQC33kmhdqfdGxDQoCuHS2WVWmxu8hicETjntPVmibYBqbpXq4LEeZ37g8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



六边形架构又称为端口-适配器架构，这个名字更容器理解。六边形架构将系统分为内部（内部六边形）和外部，内部代表了应用的业务逻辑，外部代表应用的驱动逻辑、基础设施或其他应用。



适配器分为两种类型（如下图所示），左侧代表 UI 的适配器被称为**主动适配器**（Driving Adapters），因为是它们发起了对应用的一些操作。而右侧表示和后端工具链接的适配器，被称为**被动适配器**（Driven Adapters），因为它们只会对主适配器的操作作出响应。



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCn8VA7TNRXLC5tTCCYmhBpAk02whRibnIIKjLBYsQn1HWWlIM75QCZcg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

<!--这玩意还真没有见过-->



### **4. 洋葱圈架构**



洋葱架构与六边形架构有着相同的思路，它们都通过编写适配器代码将应用核心从对基础设施的关注中解放出来，避免基础设施代码渗透到应用核心之中。这样应用使用的工具和传达机制都可以轻松地替换，可以一定程度地避免技术、工具或者供应商锁定。



不同的是洋葱架构还告诉我们，企业应用中存在着不止两个层次，它在业务逻辑中加入了一些在领域驱动设计的过程中被识别出来的层次（Application，Domain Service，Domain model，Infrastructure 等）。



另外，它还有着脱离真实基础设施和传达机制应用仍然可以运行的便利，这样可以使用 mock 代替它们方便测试。



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCoVZ5lqtUFd6Fvs3xoFhfB0V63jE4THUcskOKv0ps9YB7H0Iia5E09lg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



在洋葱架构中，明确规定了依赖的方向：

- 外层依赖内层
- 内层对外层无感知

<!--这有点凑数了，分层也是只能上层依赖下层，下层对上层无感知。本质上没有区别的-->

## **COLA 应用架构**



COLA 架构是我团队自主研发的应用架构，目前已经开源。在 COLA 的设计中，我们充分汲取了经典架构的优秀思想。除此之外，我们补充了规范设计和扩展设计，并且使用 Archetype 的方式，将架构固化下来，以便可以快速的在开发中使用。<!--这算是作者所在团队的实现吧，其实每个项目住何尝不是有一个这样的东西，但能不能开源和复用是另一码事。-->



COLA 开源地址：https://github.com/alibaba/COLA



### **1. 分层设计**

COLA 的分层是一种改良了的三层架构。主要是将传统的业务逻辑层拆分成应用层、领域层和基础实施层。如下图所示，左边是传统的分层架构，右边是 COLA 的分层架构。



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCCZfEqlLM06PeoWS9ticp5hngouxNeUgaL4oEvoObE5YVSvyAZ3bdRTQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



<!--这个跟游戏项目有点不太一样（客户端比较重，领域层不小）。而且领域内部，以及领域与应用层还有很多的粘合组件。很明显，这里的使用方式更合适轻客户端系统，只需要换一下领域层和展示层就是一个独立的程序，但其他的基础设施平台化了。-->



其每一层的作用范围和含义如下：

#### **1）展现层（Presentation Layer）**

负责以 Rest 的格式接受 Web 请求，然后将请求路由给 Application 层执行，并返回视图模型（View Model），其载体通常是 DTO（Data Transfer Object）。



#### **2）应用层（Application Layer）**

主要负责获取输入，组装上下文，做输入校验，调用领域层做业务处理，如果需要的话，发送消息通知。当然，层次是开放的，若有需要，应用层也可以直接访问基础实施层。



#### **3）领域层（Domain Layer）**

主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Entities）的函数对外部提供业务逻辑的计算和处理.



#### **4）基础实施层（Infrastructure Layer）**

主要包含 Tunnel（数据通道）、Config 和 Common。这里我们使用 Tunnel 概念来对所有的数据来源进行抽象，这些数据来源可以是数据库（MySQL，NoSql）、搜索引擎、文件系统、也可以是 SOA 服务等；Config 负责应用的配置；Common 是通用的工具类。



### **2. 扩展设计**



对于只有一个业务的简单场景，对扩展性的要求并不突出，这也是为什么扩展设计常被忽略的原因，因为我们大部分的系统都是从单一业务开始的。但是随着业务场景越来越复杂，代码里面开始出现大量的 if-else 逻辑。此时除了常规的策略模式以外，我们可以考虑在架构层面提供统一的扩展解决方案。



在扩展设计中，我们提炼出两个重要的概念，一个是**业务身份**，另一个是**扩展点**。



**业务身份是指业务在系统唯一标识一个业务或者一个场景的标志**。在具体实现中，我们使用 BizCode 来表示业务身份，其中 BizCode 采用类似 Java 包名命名空间的方式。例如，我们可以用 “ali.tmall” 表示阿里天猫业务，用 “ali.tmall.car” 表示阿里天猫的汽车业务，而用 'ali.tmall.car.aftermarket' 代表这是阿里天猫的汽车业务的后市场场景。



**每个业务或者场景都可以实现一个或多个扩展点（ExtensionPoint）**，也就是说一个业务身份加上一个扩展点，可以唯一地确定一个扩展实现（Extension）。而这个业务身份和扩展点的组合，我们将其称之为扩展坐标（ExtensionCoordinate），如下图所示。



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCyliab94ibLmB5RuiaxiaBO83GN41eLytaFSKxrAtOCOF45k6CHazFXibqEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



这样，通过业务身份+扩展点，我们就可以从框架层面实现对不同租户，不同业务，不同场景的扩展定制了。整个阿里业务中台正是基于这个思想，实现的多业务支撑的。

<!--这种就是套娃做法，以个汽车业务可能有天猫，淘宝，其他各种儿子来负责不同用户群体的需求。互联网确实有这个好处，新瓶装旧酒的成本低，比起传统行业一个平台生产各种大小和价位的轿车，SUV，然后修修改改用起来快很多。即使没人气，决定不搞了随手下掉项目也很轻松。-->



### **3. 规范设计**



任何事物都是规则性和随机性的组合。规范的意义就在于我们可以将规则性的东西固化下来，尽量减少随心所欲带来的复杂度，一致性可以降低系统复杂度。从命名到架构皆是如此，而架构本身就是一种规范和约束，破坏这个约束，也就破坏了架构。



COLA 制定了一些列的规范：包括组件（Module）结构、包（Package）结构、命名等。



比如对于组件，我们要求使用 COLA 的应用都应该遵循如下图所示的组件划分：



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCOVv7gAc5ALlp2MUuO3NstIZyEflNjshicd9kuhouFV123veb9otw0Xw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





### **4. COLA 架构总览**



在架构思想上，COLA 主张像六边形架构那样，使用端口-适配器去解耦技术细节；主张像洋葱圈架构那样，以领域为核心，并通过依赖倒置反转领域层的依赖方向。最终形成如下图所示的组件关系。



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCH0sKLjgIvIHLPQlCyMK0WF14Lias2WkhSMnWWFKD0Dvx7fKXACdr9Cg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



换一个视角，从 COLA 应用处理响应一个请求的过程来看。COLA 使用了 CQRS 来分离命令和查询的职责，使用扩展点和元数据来提升应用的扩展性。整个处理流程如下图所示：



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCkw7XlIliblYgIAzm4DID1u7HwSX2uc9fcQbNx3xLeiclcPAocaGZicTDg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





## **应用架构的核心**



纵观上面介绍的所有应用架构，我们可以发现一个共同点，就是“**核心业务逻辑和技术细节分离**”。



![image](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvnK83qqqNCz3FLiaKHxMNbQCJvNyn6BTuB3lKMBMmGtChJbxTjIbz0eSljwN1Qnt5GMM7x66y0nFrA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



是的，六边形架构、洋葱圈架构、以及 COLA 架构的核心职责就是要做核心业务逻辑和技术细节的分离和解耦。



试想一下，业务逻辑和技术细节糅杂在一起的情况，所有的代码都写在 ServiceImpl 里面，前几行代码是做 validation 的事，接下来几行是做 convert 的事，然后是几行业务处理逻辑的代码，穿插着，我们需要通过 RPC 或者 DAO 获取更多的数据，拿到数据后，又是几行 convert 的代码，在接上一段业务逻辑代码，然后还要落库，发消息.....等等。



再简单的业务，按照上面这种写代码的方式，都会变得复杂，难维护。



因此，我认为应用架构的核心使命就是要分离业务逻辑和技术细节。让核心业务逻辑可以反映领域模型和领域应用，可以复用，可以很容易被看懂。让技术细节在辅助实现业务功能的同时，可以被替换。



最后我们发现，应用架构的道就是：**让上帝的归上帝，凯撒的归凯撒。**

<!--技术这事没有这么玄乎，给够钱，氛围可以的话没人愿意写垃圾代码。谁没事干浪费自己的生命-->